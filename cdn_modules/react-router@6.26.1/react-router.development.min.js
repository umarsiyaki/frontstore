!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("react"),require("@remix-run/router")):"function"==typeof define&&define.amd?define(["exports","react","@remix-run/router"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).ReactRouter={},e.React,e.RemixRouter)}(this,function(e,B,f){"use strict";function L(r){if(r&&r.__esModule)return r;var n=Object.create(null);return r&&Object.keys(r).forEach(function(e){var t;"default"!==e&&(t=Object.getOwnPropertyDescriptor(r,e),Object.defineProperty(n,e,t.get?t:{enumerable:!0,get:function(){return r[e]}}))}),n.default=r,Object.freeze(n)}var y=L(B);function g(){return(g=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var r,n=arguments[t];for(r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e}).apply(this,arguments)}const c=y.createContext(null),d=(c.displayName="DataRouter",y.createContext(null)),o=(d.displayName="DataRouterState",y.createContext(null)),E=(o.displayName="Await",y.createContext(null)),b=(E.displayName="Navigation",y.createContext(null)),R=(b.displayName="Location",y.createContext({outlet:null,matches:[],isDataRoute:!1})),n=(R.displayName="Route",y.createContext(null));function N(){return null!=y.useContext(b)}function _(){return N()||f.UNSAFE_invariant(!1,"useLocation() may be used only in the context of a <Router> component."),y.useContext(b).location}n.displayName="RouteError";const s="You should call navigate() in a React.useEffect(), not when your component is first rendered.";function p(e){y.useContext(E).static||y.useLayoutEffect(e)}function h(){var e=y.useContext(R)["isDataRoute"];return(e?function(){let r=x(l.UseNavigateStable)["router"],n=U(m.UseNavigateStable),a=y.useRef(!1),e=(p(()=>{a.current=!0}),y.useCallback(function(e,t){void 0===t&&(t={}),f.UNSAFE_warning(a.current,s),a.current&&("number"==typeof e?r.navigate(e):r.navigate(e,g({fromRouteId:n},t)))},[r,n]));return e}:function(){N()||f.UNSAFE_invariant(!1,"useNavigate() may be used only in the context of a <Router> component.");let n=y.useContext(c),{basename:a,future:e,navigator:o}=y.useContext(E),t=y.useContext(R)["matches"],i=_()["pathname"],u=JSON.stringify(f.UNSAFE_getResolveToMatches(t,e.v7_relativeSplatPath)),l=y.useRef(!1),r=(p(()=>{l.current=!0}),y.useCallback(function(t,r){if(void 0===r&&(r={}),f.UNSAFE_warning(l.current,s),l.current)if("number"==typeof t)o.go(t);else{let e=f.resolveTo(t,JSON.parse(u),i,"path"===r.relative);null==n&&"/"!==a&&(e.pathname="/"===e.pathname?a:f.joinPaths([a,e.pathname])),(r.replace?o.replace:o.push)(e,r.state,r)}},[a,o,u,i,n]));return r})()}const r=y.createContext(null);function t(e){var t=y.useContext(R).outlet;return t&&y.createElement(r.Provider,{value:e},t)}function i(e,t){let r=(void 0===t?{}:t)["relative"];var t=y.useContext(E)["future"],n=y.useContext(R)["matches"];let a=_()["pathname"],o=JSON.stringify(f.UNSAFE_getResolveToMatches(n,t.v7_relativeSplatPath));return y.useMemo(()=>f.resolveTo(e,JSON.parse(o),a,"path"===r),[e,o,a,r])}function a(e,t){return u(e,t)}function u(e,t,r,n){N()||f.UNSAFE_invariant(!1,"useRoutes() may be used only in the context of a <Router> component.");let a=y.useContext(E)["navigator"];var o=y.useContext(R)["matches"],i=o[o.length-1];let u=i?i.params:{};var l=i?i.pathname:"/";let s=i?i.pathnameBase:"/";i=i&&i.route;{let e=i&&i.path||"";O(l,!i||e.endsWith("*"),'You rendered descendant <Routes> (or called `useRoutes()`) at "'+l+'" (under <Route path="'+e+'">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won\'t match anymore and therefore the child routes will never render.\n\nPlease change the parent <Route path="'+e+'"> to <Route path="'+("/"===e?"*":e+"/*")+'">.')}l=_();let c,d=(c=t?(v="string"==typeof t?f.parsePath(t):t,"/"===s||null!=(h=v.pathname)&&h.startsWith(s)||f.UNSAFE_invariant(!1,'When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "'+s+'" but pathname "'+v.pathname+'" was given in the `location` prop.'),v):l).pathname||"/",p=d;if("/"!==s){var h=s.replace(/^\//,"").split("/");let e=d.replace(/^\//,"").split("/");p="/"+e.slice(h.length).join("/")}let m=f.matchRoutes(e,{pathname:p});f.UNSAFE_warning(i||null!=m,'No routes matched location "'+c.pathname+c.search+c.hash+'" '),f.UNSAFE_warning(null==m||void 0!==m[m.length-1].route.element||void 0!==m[m.length-1].route.Component||void 0!==m[m.length-1].route.lazy,'Matched leaf route at location "'+c.pathname+c.search+c.hash+'" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.');var v=S(m&&m.map(e=>Object.assign({},e,{params:Object.assign({},u,e.params),pathname:f.joinPaths([s,(a.encodeLocation?a.encodeLocation(e.pathname):e).pathname]),pathnameBase:"/"===e.pathnameBase?s:f.joinPaths([s,a.encodeLocation?a.encodeLocation(e.pathnameBase).pathname:e.pathnameBase])})),o,r,n);return t&&v?y.createElement(b.Provider,{value:{location:g({pathname:"/",search:"",hash:"",state:null,key:"default"},c),navigationType:f.Action.Pop}},v):v}function M(){var e=C(),t=f.isRouteErrorResponse(e)?e.status+" "+e.statusText:e instanceof Error?e.message:JSON.stringify(e),r=e instanceof Error?e.stack:null,n="rgba(200,200,200, 0.5)",a={padding:"0.5rem",backgroundColor:n},n={padding:"2px 4px",backgroundColor:n};return console.error("Error handled by React Router default ErrorBoundary:",e),e=y.createElement(y.Fragment,null,y.createElement("p",null,"ðŸ’¿ Hey developer ðŸ‘‹"),y.createElement("p",null,"You can provide a way better UX than this when your app throws errors by providing your own ",y.createElement("code",{style:n},"ErrorBoundary")," or"," ",y.createElement("code",{style:n},"errorElement")," prop on your route.")),y.createElement(y.Fragment,null,y.createElement("h2",null,"Unexpected Application Error!"),y.createElement("h3",{style:{fontStyle:"italic"}},t),r?y.createElement("pre",{style:a},r):null,e)}const T=y.createElement(M,null);class H extends y.Component{constructor(e){super(e),this.state={location:e.location,revalidation:e.revalidation,error:e.error}}static getDerivedStateFromError(e){return{error:e}}static getDerivedStateFromProps(e,t){return t.location!==e.location||"idle"!==t.revalidation&&"idle"===e.revalidation?{error:e.error,location:e.location,revalidation:e.revalidation}:{error:(void 0!==e.error?e:t).error,location:t.location,revalidation:e.revalidation||t.revalidation}}componentDidCatch(e,t){console.error("React Router caught the following error during render",e,t)}render(){return void 0!==this.state.error?y.createElement(R.Provider,{value:this.props.routeContext},y.createElement(n.Provider,{value:this.state.error,children:this.props.component})):this.props.children}}function I(e){var{routeContext:e,match:t,children:r}=e;let n=y.useContext(c);return n&&n.static&&n.staticContext&&(t.route.errorElement||t.route.ErrorBoundary)&&(n.staticContext._deepestRenderedBoundaryId=t.route.id),y.createElement(R.Provider,{value:e},r)}function S(e,s,c,t){if(void 0===s&&(s=[]),void 0===c&&(c=null),void 0===t&&(t=null),null==e){if(!c)return null;if(c.errors)e=c.matches;else{if(!(null!=t&&t.v7_partialHydration&&0===s.length&&!c.initialized&&0<c.matches.length))return null;e=c.matches}}let d=e,p=null==c?void 0:c.errors,h=(null!=p&&(0<=(e=d.findIndex(e=>e.route.id&&void 0!==(null==p?void 0:p[e.route.id])))||f.UNSAFE_invariant(!1,"Could not find a matching route for errors on route IDs: "+Object.keys(p).join(",")),d=d.slice(0,Math.min(d.length,e+1))),!1),m=-1;if(c&&t&&t.v7_partialHydration)for(let e=0;e<d.length;e++){var r=d[e];if((r.route.HydrateFallback||r.route.hydrateFallbackElement)&&(m=e),r.route.id){var{loaderData:n,errors:a}=c,n=r.route.loader&&void 0===n[r.route.id]&&(!a||void 0===a[r.route.id]);if(r.route.lazy||n){h=!0,d=0<=m?d.slice(0,m+1):[d[0]];break}}}return d.reduceRight((t,r,e)=>{let n,a=!1,o=null,i=null,u=(c&&(n=p&&r.route.id?p[r.route.id]:void 0,o=r.route.errorElement||T,h&&(m<0&&0===e?(O("route-fallback",!1,"No `HydrateFallback` element provided to render during initial hydration"),a=!0,i=null):m===e&&(a=!0,i=r.route.hydrateFallbackElement||null))),s.concat(d.slice(0,e+1)));var l=()=>{let e;return e=n?o:a?i:r.route.Component?y.createElement(r.route.Component,null):r.route.element||t,y.createElement(I,{match:r,routeContext:{outlet:t,matches:u,isDataRoute:null!=c},children:e})};return c&&(r.route.ErrorBoundary||r.route.errorElement||0===e)?y.createElement(H,{location:c.location,revalidation:c.revalidation,component:o,error:n,children:l(),routeContext:{outlet:null,matches:u,isDataRoute:!0}}):l()},null)}var l=function(e){return e.UseBlocker="useBlocker",e.UseRevalidator="useRevalidator",e.UseNavigateStable="useNavigate",e}(l||{}),m=function(e){return e.UseBlocker="useBlocker",e.UseLoaderData="useLoaderData",e.UseActionData="useActionData",e.UseRouteError="useRouteError",e.UseNavigation="useNavigation",e.UseRouteLoaderData="useRouteLoaderData",e.UseMatches="useMatches",e.UseRevalidator="useRevalidator",e.UseNavigateStable="useNavigate",e.UseRouteId="useRouteId",e}(m||{});function v(e){return e+" must be used within a data router.  See https://reactrouter.com/routers/picking-a-router."}function x(e){var t=y.useContext(c);return t||f.UNSAFE_invariant(!1,v(e)),t}function P(e){var t=y.useContext(d);return t||f.UNSAFE_invariant(!1,v(e)),t}function U(e){t=e,(r=y.useContext(R))||f.UNSAFE_invariant(!1,v(t));var t=r,r=t.matches[t.matches.length-1];return r.route.id||f.UNSAFE_invariant(!1,e+' can only be used on routes that contain a unique "id"'),r.route.id}function C(){var e=y.useContext(n),t=P(m.UseRouteError),r=U(m.UseRouteError);return void 0!==e?e:null==(e=t.errors)?void 0:e[r]}function F(){var e=y.useContext(o);return null==e?void 0:e._data}let Y=0;const A={};function O(e,t,r){t||A[e]||(A[e]=!0,f.UNSAFE_warning(!1,r))}const j=y.startTransition;function z(e){var{routes:e,future:t,state:r}=e;return u(e,void 0,r,t)}function J(e){f.UNSAFE_invariant(!1,"A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.")}function k(e){let{basename:t="/",children:r=null,location:n,navigationType:a=f.Action.Pop,navigator:o,static:i=!1,future:u}=e,l=(N()&&f.UNSAFE_invariant(!1,"You cannot render a <Router> inside another <Router>. You should never have more than one in your app."),t.replace(/^\/*/,"/"));e=y.useMemo(()=>({basename:l,navigator:o,static:i,future:g({v7_relativeSplatPath:!1},u)}),[l,u,o,i]);let{pathname:s="/",search:c="",hash:d="",state:p=null,key:h="default"}=n="string"==typeof n?f.parsePath(n):n;var m=y.useMemo(()=>{var e=f.stripBasename(s,l);return null==e?null:{location:{pathname:e,search:c,hash:d,state:p,key:h},navigationType:a}},[l,s,c,d,p,h,a]);return f.UNSAFE_warning(null!=m,'<Router basename="'+l+'"> is not able to match the URL "'+s+c+d+"\" because it does not start with the basename, so the <Router> won't render anything."),null==m?null:y.createElement(E.Provider,{value:e},y.createElement(b.Provider,{children:r,value:m}))}var D=function(e){return e[e.pending=0]="pending",e[e.success=1]="success",e[e.error=2]="error",e}({});const q=new Promise(()=>{});class W extends y.Component{constructor(e){super(e),this.state={error:null}}static getDerivedStateFromError(e){return{error:e}}componentDidCatch(e,t){console.error("<Await> caught the following error during render",e,t)}render(){let{children:e,errorElement:t,resolve:r}=this.props,n=null,a=D.pending;if(r instanceof Promise)if(this.state.error){a=D.error;let e=this.state.error;n=Promise.reject().catch(()=>{}),Object.defineProperty(n,"_tracked",{get:()=>!0}),Object.defineProperty(n,"_error",{get:()=>e})}else r._tracked?(n=r,a="_error"in n?D.error:"_data"in n?D.success:D.pending):(a=D.pending,Object.defineProperty(r,"_tracked",{get:()=>!0}),n=r.then(e=>Object.defineProperty(r,"_data",{get:()=>e}),e=>Object.defineProperty(r,"_error",{get:()=>e})));else a=D.success,n=Promise.resolve(),Object.defineProperty(n,"_tracked",{get:()=>!0}),Object.defineProperty(n,"_data",{get:()=>r});if(a===D.error&&n._error instanceof f.AbortedDeferredError)throw q;if(a===D.error&&!t)throw n._error;if(a===D.error)return y.createElement(o.Provider,{value:n,children:t});if(a===D.success)return y.createElement(o.Provider,{value:n,children:e});throw n}}function V(e){let t=e["children"];e=F(),e="function"==typeof t?t(e):t;return y.createElement(y.Fragment,null,e)}function w(e,n){void 0===n&&(n=[]);let a=[];return y.Children.forEach(e,(r,e)=>{if(y.isValidElement(r)){let t=[...n,e];if(r.type===y.Fragment)a.push.apply(a,w(r.props.children,t));else{r.type!==J&&f.UNSAFE_invariant(!1,"["+("string"==typeof r.type?r.type:r.type.name)+"] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>"),r.props.index&&r.props.children&&f.UNSAFE_invariant(!1,"An index route cannot have child routes.");let e={id:r.props.id||t.join("-"),caseSensitive:r.props.caseSensitive,element:r.props.element,Component:r.props.Component,index:r.props.index,path:r.props.path,loader:r.props.loader,action:r.props.action,errorElement:r.props.errorElement,ErrorBoundary:r.props.ErrorBoundary,hasErrorBoundary:null!=r.props.ErrorBoundary||null!=r.props.errorElement,shouldRevalidate:r.props.shouldRevalidate,handle:r.props.handle,lazy:r.props.lazy};r.props.children&&(e.children=w(r.props.children,t)),a.push(e)}}}),a}function K(e){var t={hasErrorBoundary:null!=e.ErrorBoundary||null!=e.errorElement};return e.Component&&(e.element&&f.UNSAFE_warning(!1,"You should not include both `Component` and `element` on your route - `Component` will be used."),Object.assign(t,{element:y.createElement(e.Component),Component:void 0})),e.HydrateFallback&&(e.hydrateFallbackElement&&f.UNSAFE_warning(!1,"You should not include both `HydrateFallback` and `hydrateFallbackElement` on your route - `HydrateFallback` will be used."),Object.assign(t,{hydrateFallbackElement:y.createElement(e.HydrateFallback),HydrateFallback:void 0})),e.ErrorBoundary&&(e.errorElement&&f.UNSAFE_warning(!1,"You should not include both `ErrorBoundary` and `errorElement` on your route - `ErrorBoundary` will be used."),Object.assign(t,{errorElement:y.createElement(e.ErrorBoundary),ErrorBoundary:void 0})),t}Object.defineProperty(e,"AbortedDeferredError",{enumerable:!0,get:function(){return f.AbortedDeferredError}}),Object.defineProperty(e,"NavigationType",{enumerable:!0,get:function(){return f.Action}}),Object.defineProperty(e,"createPath",{enumerable:!0,get:function(){return f.createPath}}),Object.defineProperty(e,"defer",{enumerable:!0,get:function(){return f.defer}}),Object.defineProperty(e,"generatePath",{enumerable:!0,get:function(){return f.generatePath}}),Object.defineProperty(e,"isRouteErrorResponse",{enumerable:!0,get:function(){return f.isRouteErrorResponse}}),Object.defineProperty(e,"json",{enumerable:!0,get:function(){return f.json}}),Object.defineProperty(e,"matchPath",{enumerable:!0,get:function(){return f.matchPath}}),Object.defineProperty(e,"matchRoutes",{enumerable:!0,get:function(){return f.matchRoutes}}),Object.defineProperty(e,"parsePath",{enumerable:!0,get:function(){return f.parsePath}}),Object.defineProperty(e,"redirect",{enumerable:!0,get:function(){return f.redirect}}),Object.defineProperty(e,"redirectDocument",{enumerable:!0,get:function(){return f.redirectDocument}}),Object.defineProperty(e,"replace",{enumerable:!0,get:function(){return f.replace}}),Object.defineProperty(e,"resolvePath",{enumerable:!0,get:function(){return f.resolvePath}}),e.Await=function(e){var{children:e,errorElement:t,resolve:r}=e;return y.createElement(W,{resolve:r,errorElement:t},y.createElement(V,null,e))},e.MemoryRouter=function(e){var{basename:e,children:t,initialEntries:r,initialIndex:n,future:a}=e;let o=y.useRef(),i=(null==o.current&&(o.current=f.createMemoryHistory({initialEntries:r,initialIndex:n,v5Compat:!0})),o.current),[u,l]=y.useState({action:i.action,location:i.location}),s=(a||{})["v7_startTransition"],c=y.useCallback(e=>{s&&j?j(()=>l(e)):l(e)},[l,s]);return y.useLayoutEffect(()=>i.listen(c),[i,c]),y.createElement(k,{basename:e,children:t,location:u.location,navigationType:u.action,navigator:i,future:a})},e.Navigate=function(e){let{to:t,replace:r,state:n,relative:a}=e;N()||f.UNSAFE_invariant(!1,"<Navigate> may be used only in the context of a <Router> component.");var{future:e,static:o}=y.useContext(E),o=(f.UNSAFE_warning(!o,"<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change."),y.useContext(R))["matches"],i=_()["pathname"];let u=h(),l=(o=f.resolveTo(t,f.UNSAFE_getResolveToMatches(o,e.v7_relativeSplatPath),i,"path"===a),JSON.stringify(o));return y.useEffect(()=>u(JSON.parse(l),{replace:r,state:n,relative:a}),[u,l,a,r,n]),null},e.Outlet=function(e){return t(e.context)},e.Route=J,e.Router=k,e.RouterProvider=function(e){let{fallbackElement:t,router:n,future:r}=e,[a,o]=y.useState(n.state),i=(r||{})["v7_startTransition"],u=y.useCallback(e=>{i&&j?j(()=>o(e)):o(e)},[o,i]),l=(y.useLayoutEffect(()=>n.subscribe(u),[n,u]),y.useEffect(()=>{f.UNSAFE_warning(null==t||!n.future.v7_partialHydration,"`<RouterProvider fallbackElement>` is deprecated when using `v7_partialHydration`, use a `HydrateFallback` component instead")},[]),y.useMemo(()=>({createHref:n.createHref,encodeLocation:n.encodeLocation,go:e=>n.navigate(e),push:(e,t,r)=>n.navigate(e,{state:t,preventScrollReset:null==r?void 0:r.preventScrollReset}),replace:(e,t,r)=>n.navigate(e,{replace:!0,state:t,preventScrollReset:null==r?void 0:r.preventScrollReset})}),[n])),s=n.basename||"/";return e=y.useMemo(()=>({router:n,navigator:l,static:!1,basename:s}),[n,l,s]),y.createElement(y.Fragment,null,y.createElement(c.Provider,{value:e},y.createElement(d.Provider,{value:a},y.createElement(k,{basename:s,location:a.location,navigationType:a.historyAction,navigator:l,future:{v7_relativeSplatPath:n.future.v7_relativeSplatPath}},a.initialized||n.future.v7_partialHydration?y.createElement(z,{routes:n.routes,future:n.future,state:a}):t))),null)},e.Routes=function(e){var{children:e,location:t}=e;return a(w(e),t)},e.UNSAFE_DataRouterContext=c,e.UNSAFE_DataRouterStateContext=d,e.UNSAFE_LocationContext=b,e.UNSAFE_NavigationContext=E,e.UNSAFE_RouteContext=R,e.UNSAFE_mapRouteProperties=K,e.UNSAFE_useRouteId=function(){return U(m.UseRouteId)},e.UNSAFE_useRoutesImpl=u,e.createMemoryRouter=function(e,t){return f.createRouter({basename:null==t?void 0:t.basename,future:g({},null==t?void 0:t.future,{v7_prependBasename:!0}),history:f.createMemoryHistory({initialEntries:null==t?void 0:t.initialEntries,initialIndex:null==t?void 0:t.initialIndex}),hydrationData:null==t?void 0:t.hydrationData,routes:e,mapRouteProperties:K,unstable_dataStrategy:null==t?void 0:t.unstable_dataStrategy,unstable_patchRoutesOnNavigation:null==t?void 0:t.unstable_patchRoutesOnNavigation}).initialize()},e.createRoutesFromChildren=w,e.createRoutesFromElements=w,e.renderMatches=function(e){return S(e)},e.useActionData=function(){var e=P(m.UseActionData),t=U(m.UseLoaderData);return e.actionData?e.actionData[t]:void 0},e.useAsyncError=function(){var e=y.useContext(o);return null==e?void 0:e._error},e.useAsyncValue=F,e.useBlocker=function(n){let{router:t,basename:a}=x(l.UseBlocker),e=P(m.UseBlocker),[r,o]=y.useState(""),i=y.useCallback(e=>{if("function"!=typeof n)return!!n;if("/"===a)return n(e);var{currentLocation:e,nextLocation:t,historyAction:r}=e;return n({currentLocation:g({},e,{pathname:f.stripBasename(e.pathname,a)||e.pathname}),nextLocation:g({},t,{pathname:f.stripBasename(t.pathname,a)||t.pathname}),historyAction:r})},[a,n]);return y.useEffect(()=>{let e=String(++Y);return o(e),()=>t.deleteBlocker(e)},[t]),y.useEffect(()=>{""!==r&&t.getBlocker(r,i)},[t,r,i]),r&&e.blockers.has(r)?e.blockers.get(r):f.IDLE_BLOCKER},e.useHref=function(e,t){t=(void 0===t?{}:t).relative,N()||f.UNSAFE_invariant(!1,"useHref() may be used only in the context of a <Router> component.");let{basename:r,navigator:n}=y.useContext(E);var{hash:e,pathname:t,search:a}=i(e,{relative:t});let o=t;return"/"!==r&&(o="/"===t?r:f.joinPaths([r,t])),n.createHref({pathname:o,search:a,hash:e})},e.useInRouterContext=N,e.useLoaderData=function(){var e=P(m.UseLoaderData),t=U(m.UseLoaderData);if(!e.errors||null==e.errors[t])return e.loaderData[t];console.error("You cannot `useLoaderData` in an errorElement (routeId: "+t+")")},e.useLocation=_,e.useMatch=function(e){N()||f.UNSAFE_invariant(!1,"useMatch() may be used only in the context of a <Router> component.");let t=_()["pathname"];return y.useMemo(()=>f.matchPath(e,f.UNSAFE_decodePath(t)),[t,e])},e.useMatches=function(){let{matches:e,loaderData:t}=P(m.UseMatches);return y.useMemo(()=>e.map(e=>f.UNSAFE_convertRouteMatchToUiMatch(e,t)),[e,t])},e.useNavigate=h,e.useNavigation=function(){return P(m.UseNavigation).navigation},e.useNavigationType=function(){return y.useContext(b).navigationType},e.useOutlet=t,e.useOutletContext=function(){return y.useContext(r)},e.useParams=function(){var e=y.useContext(R)["matches"];return(e=e[e.length-1])?e.params:{}},e.useResolvedPath=i,e.useRevalidator=function(){let e=x(l.UseRevalidator),t=P(m.UseRevalidator);return y.useMemo(()=>({revalidate:e.router.revalidate,state:t.revalidation}),[e.router.revalidate,t.revalidation])},e.useRouteError=C,e.useRouteLoaderData=function(e){return P(m.UseRouteLoaderData).loaderData[e]},e.useRoutes=a,Object.defineProperty(e,"__esModule",{value:!0})});